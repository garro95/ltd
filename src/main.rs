/*
 *  Copyright Â© 2018 Gianmarco Garrisi
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
extern crate petgraph;
extern crate rand;
extern crate rayon;
#[macro_use] extern crate quicli;

use std::sync::RwLock;
use std::path::PathBuf;
use std::process::{Command, Stdio};
use std::ffi::OsString;
use std::io::Write;

use petgraph::prelude::*;
use petgraph::graph::EdgeReference;
use petgraph::dot::Dot;

use rand::{SeedableRng, distributions::{Sample, Range}};

use quicli::prelude::*;

fn parse_seed(seed: &str) -> [u32;4] {
    let mut seed:u128 = seed.parse().expect("Unable to parse random seed");
    let mut parsed = [0;4];
    for i in 1..=4 {
        parsed[4-i] = (seed & std::u32::MAX as u128) as u32;
        seed = seed >> 32;
    }
    parsed
}

/// Heuristically compute a good physical topology to deliver the
/// traffic generated by a randomly generated, completely connected
/// logical network
#[derive(Debug, StructOpt)]
struct Interface {
    /// Number of nodes in the network
    #[structopt(long="nodes", short="n")]
    n: usize,
    /// Number of lasers and receivers. This determins the number of
    /// physical links that can enter and exit a node
    #[structopt(long="delta", short="D")]
    delta: usize,
    /// Random seed. The traffic is genearated using a seeded random number generator,
    /// in order to be consistent between two run. You can change it to change the result
    /// of the computation.
    #[structopt(long="seed", short="s", default_value="1234", parse(from_str="parse_seed"))]
    seed: [u32;4],
    /// If specified, the final computed graph will be output on the specified file using graphviz.
    /// The type of the output file will be desumed from the extension. If the extension is not
    /// specified, will default to dot
    #[structopt(long="output-file", short="o", parse(from_os_str))]
    output_file: Option<PathBuf>,
    /// Specify if it is possible to split the traffic on one node in order to send it
    /// in parallel on more lightpaths.
    #[structopt(long="split", short="s")]
    splittable: bool,
}

main!(|args:Interface| {
    let mut logic = create_logical_topology(args.n, args.seed);
    // Heuristically find a heavy Hamilton cycle
    let start = find_start(&logic);

    // Create a graph containing the found cycle
    let mut phisical: Graph<usize, f64> = Graph::new();
    for i in 0..args.n {
        phisical.add_node(i);
    }
    let mut connected = vec![false; args.n];
    let mut unconnected = args.n-1;
    connected[start] = true;
    let (mut indegree, mut outdegree) = (vec![0;args.n], vec![0;args.n]);
    let mut a = NodeIndex::new(start);
    while unconnected > 0 {
        let edge_id;
        {
            let e:EdgeReference<_> = logic.edges_directed(a, Direction::Outgoing)
                .filter(|e| !connected[e.target().index()])
                .max_by(|e1, e2| {
                    match e2.weight().partial_cmp(e1.weight()) {
                        Some(o) => o,
                        None => std::cmp::Ordering::Equal
                    }
                }).unwrap();
            phisical.add_edge(a, e.target(), *e.weight());
            edge_id = e.id();
            unconnected -= 1;
            connected[e.target().index()] = true;
            outdegree[a.index()] += 1;
            indegree[e.target().index()] += 1;
            a = e.target();
        }
        logic.remove_edge(edge_id);
    }
    let e = logic.find_edge(a, NodeIndex::new(start)).unwrap();
    phisical.add_edge(a, NodeIndex::new(start), *logic.edge_weight(e).unwrap());
    logic.remove_edge(e);

    // If there is still space, try to add more arcs, starting from the heaviest
    if args.delta > 1 {
        let mut sorted_edges = Vec::from(logic.raw_edges());
        sorted_edges.par_sort_unstable_by(|e1, e2| {
            match e2.weight.partial_cmp(&e1.weight) {
                Some(o) => o,
                None => std::cmp::Ordering::Equal
            }
        });
        for e in sorted_edges {
            if outdegree[e.source().index()] < args.delta && indegree[e.target().index()] < args.delta {
                phisical.add_edge(e.source(), e.target(), e.weight);
                outdegree[e.source().index()] += 1;
                indegree[e.target().index()] += 1;
            }
        }
    }

    // TODO: Assign all the remaining traffic to the existing paths.

    output_result(&phisical, args.output_file);
});

fn create_logical_topology(nodes:usize, seed:[u32;4]) -> Graph<usize, f64>{
    let mut rng = rand::XorShiftRng::from_seed(seed);
    let mut traffic_values = Range::new(0.0, 1.0);

    // Create a logical topology that describes the traffic from one node to each other.
    let mut logic = Graph::new();

    for i in 0..nodes {
        logic.add_node(i);
    }

    for from in 0usize..nodes {
        for to in (0usize..nodes).filter(|&a| a != from) {
            logic.add_edge(NodeIndex::new(from), NodeIndex::new(to), traffic_values.sample(&mut rng));
        }
    }
    logic
}

fn find_start(logic: &Graph<usize, f64>) -> usize {
    let max_weight = RwLock::new((0, 0.0));
    let n = logic.node_count();

    (0usize..n).into_par_iter().for_each(|start| {
        let mut tot_weight = 0.0;
        let mut connected = vec![false; n];
        let mut unconnected = n-1;
        connected[start] = true;
        let mut a = NodeIndex::new(start);
        while unconnected > 0 {
            let e:EdgeReference<_> = logic.edges_directed(a, Direction::Outgoing)
                .filter(|e| !connected[e.target().index()])
                .max_by(|e1, e2| {
                    match e2.weight().partial_cmp(e1.weight()) {
                        Some(o) => o,
                        None => std::cmp::Ordering::Equal
                    }
                }).unwrap();
            unconnected -= 1;
            connected[e.target().index()] = true;
            a = e.target();
            tot_weight += e.weight();
        }
        let e = logic.find_edge(a, NodeIndex::new(start)).unwrap();
        tot_weight += logic.edge_weight(e).unwrap();
        if max_weight.read().unwrap().1 < tot_weight {
            *max_weight.write().unwrap() = (start, tot_weight);
        }
    });

    max_weight.into_inner().unwrap().0
}

fn output_result(g: &Graph<usize, f64>, output_file: Option<PathBuf>) {
    let dot = Dot::new(g);

    match output_file {
        None => println!("{:?}", dot),
        Some(p) => {
            let mut type_arg = OsString::from("-T");
            if let Some(ext) = p.extension(){
                type_arg.push(ext);
            } else {
                type_arg.push("dot");
            }
            let mut graphviz = Command::new("dot")
                .arg(type_arg)
                .arg("-o")
                .arg(p)
                .stdin(Stdio::piped())
                .spawn().expect("Failed to run graphviz' dot command");
            {
                let mut stdin = graphviz.stdin.as_mut().expect("Failed to open graphviz' dot stdin");
                write!(&mut stdin, "{:?}", dot).unwrap();
            }
        }
    }
}
